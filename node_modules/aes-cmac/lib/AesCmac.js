"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AesCmac = void 0;
const crypto_1 = require("crypto");
const BufferTools_1 = require("./BufferTools");
class AesCmac {
    constructor(key) {
        this.key = key;
        this.algos = {
            16: `aes-128-cbc`,
            24: `aes-192-cbc`,
            32: `aes-256-cbc`,
        };
        this.blockSize = 16;
        if ((key instanceof Buffer) === false) {
            throw new Error(`The key must be provided as a Buffer.`);
        }
        if ((key.length in this.algos) === false) {
            throw new Error(`Key size must be 128, 192, or 256 bits.`);
        }
        this.algo = this.algos[key.length];
        this.subkeys = this.generateSubkeys();
    }
    generateSubkeys() {
        const rb = Buffer.from(`00000000000000000000000000000087`, `hex`);
        const z = Buffer.alloc(this.blockSize, 0);
        const l = this.aes(z);
        let key1 = BufferTools_1.BufferTools.bitShiftLeft(l);
        if (l[0] & 0x80) {
            key1 = BufferTools_1.BufferTools.xor(key1, rb);
        }
        let key2 = BufferTools_1.BufferTools.bitShiftLeft(key1);
        if (key1[0] & 0x80) {
            key2 = BufferTools_1.BufferTools.xor(key2, rb);
        }
        return { key1, key2 };
    }
    getSubKeys() {
        const key1 = Buffer.alloc(this.blockSize);
        const key2 = Buffer.alloc(this.blockSize);
        this.subkeys.key1.copy(key1);
        this.subkeys.key2.copy(key2);
        return { key1, key2 };
    }
    calculate(message) {
        if ((message instanceof Buffer) === false) {
            throw new Error(`The message must be provided as a Buffer.`);
        }
        const blockCount = this.getBlockCount(message);
        let x = Buffer.alloc(this.blockSize, 0);
        let y = Buffer.alloc(0);
        for (let i = 0; i < blockCount - 1; i++) {
            const from = i * this.blockSize;
            const block = message.slice(from, from + this.blockSize);
            y = BufferTools_1.BufferTools.xor(x, block);
            x = this.aes(y);
        }
        y = BufferTools_1.BufferTools.xor(x, this.getLastBlock(message));
        x = this.aes(y);
        return x;
    }
    getBlockCount(message) {
        const blockCount = Math.ceil(message.length / this.blockSize);
        return blockCount === 0 ? 1 : blockCount;
    }
    aes(message) {
        const z = Buffer.alloc(this.blockSize, 0);
        const cipher = (0, crypto_1.createCipheriv)(this.algo, this.key, z);
        const result = cipher.update(message);
        cipher.final();
        return result;
    }
    getLastBlock(message) {
        const blockCount = this.getBlockCount(message);
        const paddedBlock = this.padding(message, blockCount - 1);
        let complete = false;
        if (message.length > 0) {
            complete = (message.length % this.blockSize) === 0;
        }
        const key = complete ? this.subkeys.key1 : this.subkeys.key2;
        return BufferTools_1.BufferTools.xor(paddedBlock, key);
    }
    padding(message, blockIndex) {
        const block = Buffer.alloc(this.blockSize, 0);
        const from = blockIndex * this.blockSize;
        const bytes = message.copy(block, 0, from);
        if (bytes !== this.blockSize) {
            block[bytes] = 0x80;
        }
        return block;
    }
}
exports.AesCmac = AesCmac;
